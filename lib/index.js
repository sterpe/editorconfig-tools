// Generated by CoffeeScript 1.11.1
var Rules, W, _, check, editorconfig, fix, fs, infer, path, requireTree;

_ = require('lodash');

W = require('when');

editorconfig = require('editorconfig');

fs = require('graceful-fs');

path = require('path');

requireTree = require('require-tree');

Rules = requireTree('./rules');

check = function(files) {
  var exitCode, promises;
  exitCode = 0;
  promises = [];
  Object.keys(Rules).forEach(function(ruleName) {
    var Rule;
    Rule = Rules[ruleName];
    return files.forEach(function(filePath) {
      var property;
      if (fs.lstatSync(filePath).isDirectory()) {
        return;
      }
      property = void 0;
      return promises.push((new Rule(filePath)).then(function(returnedProperty) {
        property = returnedProperty;
        return property.check();
      }).then(function(res) {
        return {
          res: res,
          file: filePath,
          rule: property.propertyName
        };
      })["catch"](function(err) {
        return {
          file: filePath,
          rule: property.propertyName,
          error: err
        };
      }));
    });
  });
  return W.all(promises).done(function(res) {
    var file, i, j, len, len1, match, matches, text, verbose;
    files = _.uniq(_.map(res, 'file'));
    for (i = 0, len = files.length; i < len; i++) {
      file = files[i];
      matches = _.filter(res, {
        file: file
      });
      verbose = false;
      if (verbose || _.compact(_.map(matches, 'error')).length > 0) {
        for (j = 0, len1 = matches.length; j < len1; j++) {
          match = matches[j];
          if (match.error != null) {
            exitCode = 1;
            text = file + " failed " + match.rule;
            if (match.error.lineNumber != null) {
              text += " on line " + match.error.lineNumber;
            }
            if (match.error.message != null) {
              text += ": " + match.error.message;
            }
            console.log(text);
          } else if (verbose) {
            if (match.res === null) {
              console.log(file + " ignored " + match.rule + " (no setting defined)");
            } else {

            }
          }
        }
      }
    }
    return process.exit(exitCode);
  });
};

fix = function(files) {
  var Rule, filePath, fn, i, j, len, len1, promise, ref, results, ruleName;
  results = [];
  promise = W.resolve();
  ref = Object.keys(Rules);
  for (i = 0, len = ref.length; i < len; i++) {
    ruleName = ref[i];
    Rule = Rules[ruleName];
    fn = function(Rule, filePath) {
      var property;
      property = void 0;
      return promise = promise.then(function() {
        return new Rule(filePath);
      }).then(function(returnedProperty) {
        property = returnedProperty;
        return property.fix();
      }).then(function(res) {
        return results.push({
          res: res,
          file: filePath,
          rule: property.propertyName
        });
      })["catch"](function(err) {
        return results.push({
          file: filePath,
          rule: property.propertyName,
          error: err
        });
      });
    };
    for (j = 0, len1 = files.length; j < len1; j++) {
      filePath = files[j];
      if (fs.lstatSync(filePath).isDirectory()) {
        continue;
      }
      fn(Rule, filePath);
    }
  }
  return promise.done(function() {
    var k, len2, result, results1, verbose;
    verbose = true;
    results1 = [];
    for (k = 0, len2 = results.length; k < len2; k++) {
      result = results[k];
      if (result.error != null) {
        results1.push(console.log(result.file + " " + result.error.message));
      } else if (verbose) {
        results1.push(console.log(result.file + " fixed"));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  });
};

infer = function(files) {
  var promises;
  promises = [];
  Object.keys(Rules).forEach(function(ruleName) {
    var Rule;
    Rule = Rules[ruleName];
    return files.forEach(function(filePath) {
      var property;
      if (fs.lstatSync(filePath).isDirectory()) {
        return;
      }
      property = void 0;
      return promises.push((new Rule(filePath)).then(function(returnedProperty) {
        property = returnedProperty;
        return property.infer();
      }).then(function(res) {
        return {
          res: res,
          file: filePath,
          rule: property.propertyName
        };
      })["catch"](function(err) {
        return {
          file: filePath,
          rule: property.propertyName,
          error: err
        };
      }));
    });
  });
  return W.all(promises).done(function(res) {
    var distributionOfValues, filteredResults, group, groups, i, indentStyle, j, k, len, len1, len2, property, ref, result, results1, rule, ruleGroup, rules, selector, sortedValues, value;
    rules = {};
    _.remove(res, function(e) {
      return e.res == null;
    });
    filteredResults = [];
    for (i = 0, len = res.length; i < len; i++) {
      result = res[i];
      if (result.rule === 'indent_char') {
        indentStyle = (result.res === '\t' ? 'tab' : 'space');
        filteredResults.push({
          rule: 'indent_style',
          res: indentStyle,
          file: result.file
        });
        if (indentStyle === 'space') {
          filteredResults.push({
            rule: 'indent_size',
            res: String(result.res.length),
            file: result.file
          });
        }
      } else {
        result.res = String(result.res);
        filteredResults.push(result);
      }
    }
    groups = _.groupBy(filteredResults, 'rule');
    for (property in groups) {
      group = groups[property];
      distributionOfValues = _.toPairs(_.countBy(_.map(group, 'res'), function(x) {
        return x;
      }));
      sortedValues = _.sortBy(distributionOfValues, function(x) {
        return -x[1];
      });
      if (rules['[*]'] == null) {
        rules['[*]'] = [];
      }
      rules['[*]'].push([property, sortedValues[0][0]]);
      ref = sortedValues.slice(1);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        value = ref[j];
        files = _.map(_.filter(group, {
          res: value[0]
        }), 'file');
        selector = "[{" + (files.join(',')) + "}]";
        if (rules[selector] == null) {
          rules[selector] = [];
        }
        rules[selector].push([property, value[0]]);
      }
    }
    results1 = [];
    for (selector in rules) {
      ruleGroup = rules[selector];
      console.log(selector);
      for (k = 0, len2 = ruleGroup.length; k < len2; k++) {
        rule = ruleGroup[k];
        console.log(rule[0] + " = " + rule[1]);
      }
      results1.push(console.log(''));
    }
    return results1;
  });
};

module.exports = {
  check: check,
  fix: fix,
  infer: infer
};
